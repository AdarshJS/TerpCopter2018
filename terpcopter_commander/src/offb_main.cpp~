
//
// THIS FILE CONTAINS A SAMPLE MISSION IMPLEMENTATION THROUGH
// MAVROS SERVICES
//
// COPYRIGHT BELONGS TO THE AUTHOR OF THIS CODE
//
// AUTHOR : SAIMOULI KATRAGADA
// AFFILIATION : UNIVERSITY OF MARYLAND
// EMAIL : SKATRAGA@TERPMAIL.UMD.EDU
//
// THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THE GPLv3 LICENSE
// THE WORK IS PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF
// THE WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS 
// PROHIBITED.
// 
// BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO
// BE BOUND BY THE TERMS OF THIS LICENSE. THE LICENSOR GRANTS YOU THE RIGHTS
// CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND
// CONDITIONS.
//

///////////////////////////////////////////
//
//	LIBRARIES
//
///////////////////////////////////////////
#include <offbFunction.h>

// mavros_msgs::State current_state;
// void state_cb(const mavros_msgs::State::ConstPtr& msg){
//     current_state = *msg;
// }

// nav_msgs::Odometry current_odom;
// void posState(const nav_msgs::Odometry::ConstPtr& msgP) {
//     current_odom = *msgP;
//     //ROS_INFO("Position-> x: [%f], y: [%f], z: [%f]", msgP->pose.pose.position.x,msgP->pose.pose.position.y, msgP->pose.pose.position.z);
//     //ROS_INFO("Orientation-> x: [%f], y: [%f], z: [%f], w: [%f]", msgP->pose.pose.orientation.x, msgP->pose.pose.orientation.y, msgP->pose.pose.orientation.z, msgP->pose.pose.orientation.w);
// }

///////////////////////////////////////////
//
//	MAIN FUNCTION
//
///////////////////////////////////////////


int main(int argc, char **argv){
    ros::init(argc, argv, MISSION_NODE);
    //ros::NodeHandle nh;

    // Converting constructor
    TerpCopterMission mission;


    ros::Subscriber state_sub = 
        mission.nh.subscribe<mavros_msgs::State>
            ("mavros/state", 10, &TerpCopterMission::state_cb,&mission);

    ros::Subscriber pos_sub = 
        mission.nh.subscribe<nav_msgs::Odometry>
            ("mavros/local_position/odom", 10, &TerpCopterMission::state_cu,&mission);

    mission.local_pos_pub = 
        mission.nh.advertise<geometry_msgs::PoseStamped>
            ("mavros/setpoint_position/local", 10);

    //attitude setpoints run at higher refresh rates than position 
    // mission.pub_att = 
    //     mission.nh.advertise<geometry_msgs::PoseStamped>
    //         ("/mavros/setpoint_attitude/attitude",100);

    ros::ServiceClient arming_client = 
        mission.nh.serviceClient<mavros_msgs::CommandBool>
            ("mavros/cmd/arming");
    ros::ServiceClient set_mode_client = 
        mission.nh.serviceClient<mavros_msgs::SetMode>
            ("mavros/set_mode");

    //the setpoint publishing rate MUST be faster than 2Hz
    ros::Rate rate(50.0);

    // wait for FCU connection
    while(ros::ok() && !mission.current_state.connected){
        ros::spinOnce();
        rate.sleep();
    }

    //geometry_msgs::PoseStamped pose;
    //geometry_msgs::PoseStamped cmd_att;
    // mission.pose.pose.position.x = 0;
    // mission.pose.pose.position.y = 0;
    // mission.pose.pose.position.z = 2;

    //mission.hover(0,0,2);
    //send a few setpoints before starting
    for(int i = 100; ros::ok() && i > 0; --i){
        mission.local_pos_pub.publish(mission.pose);
        ros::spinOnce();
        rate.sleep();
    }

    mavros_msgs::SetMode offb_set_mode;
    offb_set_mode.request.custom_mode = "OFFBOARD";

    mavros_msgs::CommandBool arm_cmd;
    arm_cmd.request.value = true;

    ros::Time last_request = ros::Time::now();

    while(ros::ok()){
        // if( mission.current_state.mode != "OFFBOARD" &&
        //     (ros::Time::now() - last_request > ros::Duration(5.0))){
        //     if( set_mode_client.call(offb_set_mode) &&
        //         offb_set_mode.response.mode_sent){
        //         ROS_INFO("Offboard enabled");
        //     }
        //     last_request = ros::Time::now();
        // } else {
        //     if( !mission.current_state.armed &&
        //         (ros::Time::now() - last_request > ros::Duration(5.0))){
        //         if( arming_client.call(arm_cmd) &&
        //             arm_cmd.response.success){
        //             ROS_INFO("Vehicle armed");
        //         }
        //         last_request = ros::Time::now();
        //     }
        // }

        // setpoint 1= (12,2.1,2)
        // setpoint 2= (yaw (rot about z, +/- 120))
        // setpoint 3= ()

        // if (current_odom.pose.pose.position.z >= 0.9 * pose.pose.position.z ){
        //     pose.pose.position.x = 3;
        //     pose.pose.position.y = 2;
        //     ROS_INFO("x=3, y=2");
        //     local_pos_pub.publish(pose);
        // }

        // if (current_odom.pose.pose.position.x >= 0.9 *pose.pose.position.x && 
        //      current_odom.pose.pose.position.y >= 0.9 *pose.pose.position.z){
        //         cmd_att.pose.orientation.x = 0.9239;
        //         cmd_att.pose.orientation.y= 0.3827;
        //         pub_att.publish(pose);}

             
        mission.hover(2.0);
        //mission.local_pos_pub.publish(mission.pose);
        mission.moveX(1.0,2.0,true);

        ros::spinOnce();
        rate.sleep();
    }

    return 0;
}

void TerpCopterMission::state_cb(const mavros_msgs::State::ConstPtr& msg){
    current_state = *msg;
}

void TerpCopterMission::state_cu (const nav_msgs::Odometry::ConstPtr& msgS){
    //ROS_INFO("Position x: [%f], y: [%f], z: [%f]", msgP->pose.pose.position.x,msgP->pose.pose.position.y, msgP->pose.pose.position.z);
    current_odom = *msgS;
}

void TerpCopterMission::hover(float z){

    pose.pose.position.x = 0.0; //m
    pose.pose.position.y = 0.0;
    pose.pose.position.z = z;

    local_pos_pub.publish(pose);
}

void TerpCopterMission::moveX(float x, float z, bool isForwardX){
    if (isForwardX)
        pose.pose.position.x = abs(x);
    else
        pose.pose.position.x = -abs(x);

    pose.pose.position.y = 0;
    pose.pose.position.z = abs(z);

    //double t0 = ros::Time::now().toSec();
    double current_distance = 0.0;

    do{
        local_pos_pub.publish(pose);
        //double t1 = ros::Time::now().toSec();
        current_distance = current_odom.pose.pose.position.x;
    }while(current_distance <= 0.93 * pose.pose.position.x);

    pose.pose.position.x = 0;
    local_pos_pub.publish(pose);

}

void TerpCopterMission::moveY(float y, float z, bool isForwardY){
    if (isForwardY)
        pose.pose.position.y = abs(y);
    else
        pose.pose.position.y = -abs(y);

    pose.pose.position.x = 0;
    pose.pose.position.z = abs(z);

    //double t0 = ros::Time::now().toSec();
    double current_distance = 0.0;

    do{
        local_pos_pub.publish(pose);
        //double t1 = ros::Time::now().toSec();
        current_distance = current_odom.pose.pose.position.y;
    }while(current_distance <= 0.93 * pose.pose.position.y);

    pose.pose.position.y = 0;
    local_pos_pub.publish(pose);

}

void TerpCopterMission::yaw (float x, float y, float z){
// convert euler to quaternions

}


